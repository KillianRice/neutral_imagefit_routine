function  analyVar = AnalysisVariables()
% Master file to control all similar variables to be passed between
% background analysis, cloud fitting, and graphing routines.
%
% INPUTS:
%   none
%
% OUTPUTS:
%   analyVar - Structure containing all the variables defined in
%              this function.
%
% MISC:
%#ok<*STRNU>
%#ok<*NASGU> - suppress all instances of 'this variables may not be used' 
%              because the who() builds a structure with all variables
%              defined in the workspace.
%
% NOTE:
%    - LatticeAxesFit follows form of [Origin, +Z, -Z, +X, -X, +Y, -Y] where 
%           - Z is the axis in and out of the imaging plane ----------- Arm B
%           - X is the axis nearly perpendicular to the imaging plane - Arm A
%           - Y is the axis vertical to the imaging plane ------------- Arm C
%    - Labels generated by create_plot_AtomNum expect this ordering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Realtime and Acquisition Settings
% Real time fitting? (Used to provide quick analyze during data taking)
quickFit = 0;     % 1 to limit background evaluations, 0 for no limit.

% EXPERIMENTAL OPTIONS AND SETTINGS
%%-----------------------------------------------------------------------%%
sampleType     = 'Thermal';  % Options are Thermal, BEC, or Lattice
isotope        = 87; % Isotope mass used to select applicable models for fitting. Options are 84, 86, or 88 (87 not currently supported)
imgDetune      = 0;  % image beam detuning in Hz (as of 9/17/2014)
pureSample     = 0;  % Flags whether BEC samples have a thermal fraction present or not (ignored for Thermal and Lattice samples)
winToFit       = {'Central'}; % Specify which windows to fit, this generates the vector LatticeAxesFit
matrixSize     = [1280 1024]; % Matrix size of camera output
CameraMag      = 1;  % Currently can do 1x or 4x magnification (input 1 or 4)
CCDbinning     = 1;  % Number of pixels binned when first recording data

% Control the independent data
applyIndCalib  = 1;      % Boolean to control whether a calibration function is applied to the independent variable, if true a function must be defined 
TimeOrDetune   = 'Wavemeter'; % Named for (dumb) historical reasons but this controls the presentation of the X-axis on plots
% Valid options are {Time, Detuning, Bragg, 3P1 Detuning, Voltage, Offset Lock Detuning, Wavemeter} Line 431 to modify these properties

%% PARAMETER EVALUATION AND PLOTTING FLAGS
% Parameters are only extracted when it makes sense to plot them (i.e. BEC number is plotted for condensates but ignored for thermal gases)
%%-----------------------------------------------------------------------%%
% Common Plotting flags
SavePlotData  = 1; % Boolean to allow aggregation of variables from plotting into output structure
plotFitEval   = 0; % Boolean to display plots showing the fit, cloud evolution, and residuals
plotInstParam = 1; % Boolean to extract and display 1st order parameters such as temperature, size, and number
plotMeanParam = 1; % Boolean to average instantaneous parameters across multiple scans
plotFitLine   = 1; % Boolean to extract higher order parameters by fitting instantaneous parameters

% Normalize mean atom number
normMeanNum = 0; % Boolean to plot the mean atom number normalized to the first and last 5 points of each avgerage spectrum.

%% HIGHER ORDER ANALYSIS CONTROL
%%-----------------------------------------------------------------------%%
% Called within imagefit_ParamEval
% Allows secondary analysis of parameters extracted from the number distribution fit
% Functions ahould expect input arguments of analyvar, indivDataset, and avgDataset from imagefit_ParamEval
%
% Functions are selected by the booleans in lcl_logicFitLine (i.e. [1 0 0 0] triggers lcl_validFitLine(1))
%   Spectrum_Fit - Fits spectrum to gaussian (or lorentzian) and estimates rabi freq. based on width
%   KapitzaDirac - Fits number oscillations in 2hk peaks to calibrate lattice depth
%   Cloud_Pos    - Plot spatial center of cloud (option to fit oscillation for trap freq. measurements)
% Future Plans
%   lifetime_n   - (n = 1,2,3) Fits number decay to decaying exponential with n-body decay constant
lcl_validFitLine = {'Spectrum_Fit' 'KapitzaDirac' 'Cloud_Pos' 'Lifetime_Fit' 'Rydberg_Dress' 'Rabi_Oscillations' 'Magnetic_Lifetime' 'Sr86_gsMoleculeAnalysis' 'TripletP1Fit' 'PicoScope' 'Wavemeter'};
lcl_logicFitLine = [0 0 0 0 0 0 0 0 0 0 0];

%% WARNING!!!! %% WARNING!!!! %% WARNING!!!! %% WARNING!!!! %% WARNING!!!! %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-- Do not modify variables below this line without knowing what you are  --%
%-- doing. Modification may result in failure of the analysis routine.    --%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BACKGROUND SUBTRACTION ROUTINE
%%-----------------------------------------------------------------------%%
varianceLim  = 0.975; % Amount of variance to choose principal component vectors for background subtraction
dimReduceLim = 25;    % Maximum number of states where all states are used, over this variance up to varianceLim is used  

%% 2D NUMBER DISTRIBUTION FITTING ROUTINE
%%-----------------------------------------------------------------------%%
% Fitting flags
weightPeak      = 0; % 1 to weight sample peak with normalized error relative to average pixel value (get_fit_image)
fitSmoothOD     = 0; % Boolean to average data with smoothFilt, could make it easier to fit

% Fitting specific values
softwareBinSize = 1; % Number of pixels square to bin (i.e. area of bin, in # of pixels = softwareBinSize*softwareBinSize (TrimAndBin)
cutBorders      = 0; % number of column and rows to trim on either side of the data matrix (TrimAndBin)
NoiseNumVec     = 5; % number of column and rows at the corners to find the uncertainties/noise (get_fit_params)
gaussFiltAmp    = 7; % Amplitude of gaussian filter applied when finding initial guesses for fitting (get_fit_params)
gaussFiltSig    = 2; % Width of gaussian filter applied when finding initial guesses for fitting (get_fit_params)
ampBimodalGuess = 0.1; % When fitting bimodal feature, initial guess of thermal amplitude is this percentage of BEC peak (get_fit_params)
smoothFilt      = @(x,y) medfilt2(x,y); % Smooth noise on image to evaluate fit (create_plot_fitEval)
smoothFiltMat   = 2*[1 1];              % Defines the moving box that the smoothing filter effects

% Bounds on fit parameters 
lsqAmpBnd       = {0 2}; % Amplitude bounds 
lsqSigBnd       = {0 'analyVar.cloudWinRadAtom'}; % Width bounds - upper bound is window radius (entire cloud must be in view)
lsqCntBnd       = {0 '2*analyVar.cloudWinRadAtom + 1'}; % Peak position - upper bound is window radius
lsqLinBnd       = {-Inf Inf}; % Linear background terms bound, all allowed to range from 0 to Inf

%% PARAMETER EVALUATION AND PLOTTING ROUTINE
% Parameters are only extracted when it makes sense to plot them (i.e. BEC number is plotted for condensates but ignored for thermal gases)
%%-----------------------------------------------------------------------%%
% Plotting presentation defaults
titleFontSize = 18;
axisFontSize  = 25;
labelFontSize = 35;
markerSize    = 14;
condOffset    = 0.1;    % Add offset to condensate cross-section to separate from X cut
ylimMeanTrimPercent = .25;  % Percentage used in meantrim for determining mean away from outliers for y limits
yPlotLimBounds      = 1; % +/- this percentage around mean for y limits
COLORS  = [0 0.4470    0.7410; 0.8500 0.3250 0.0980; 0.9290 0.6940 0.1250; 0.4940 0.1840 0.5560; 0.4660 0.6740 0.1880; 0.3010 0.7450 0.9330;...
     0.6350 0.0780 0.1840; 0 0 0;1 0 0;0 1 0; 0 0 1; .25 .25 .25; 0 .75 0; 0 .75 .75; .5 0 .5; .75 0 .75;0 0 1;0 0 0;1 0 .25;0 .75 0; .5 0 .5; 0 1 0;...
     0 .75 0; 0 .75 .75; .5 0 .5; .75 0 .75;0 0 1;0 0 0;1 0 .25;0 .75 0; .5 0 .5; 0 1 0; 0 .75 0; 0 .75 .75; .5 0 .5; .75 0 .75;0 0 1;...
     0 0 0;1 0 .25;0 .75 0; .5 0 .5; 0 1 0; 0 .75 0; 0 .75 .75; .5 0 .5; .75 0 .75;0 0 1;0 0.4470 0.7410; 0.8500 0.3250 0.0980; 0.9290 0.6940 0.1250; 0.4940 0.1840 0.5560;];
MARKERS = {'-o','-s','-^','-d','-v','-p','-<','-h','->','-x','-*','-+','-.','-o','-s','-^','-d','-v','-p','-<','-h','->','-x','-*',...
    '-+','-.','-o','-s','-^','-d','-v','-p','-<','-h','->','-x','-*','-+','-.','-o','-s','-^','-d','-v','-p','-<','-h','->','-x','-*','-+','-.'};

%% EXPERIMENT SPECIFIC SETTING AND FLAGS
% These are generally settings looked for by the indivdual plugins enabled in the section above
%%-----------------------------------------------------------------------%%
% Cloud_Pos - Trap Frequency oscillation fitting - 2015.03
fitStatFlag  = 0;     % Shows statistics about the center position of the cloud
oscFitFlag   = 0;     % Flag whether to fit spatial oscillation (used for trap frequency measurements)
    oscAxis  = 'y';   % Flag which axis is oscillating in space
pixelSizeFit = 0;     % Flag fitting for the pixel size
xbinWidth    = 1;     % Bin sizes (in pixels) for histogram
ybinWidth    = 1;

% Lifetime_Fit - Fits exponential decay as a functino of time - 2016.06
decayFit      = 'oneBody'; % Currenly only oneBody implemented (2016.06.08)

% Rydberg_Dress - 2014.11
flagSpecFit   = 0; % Fit number spectrum
flagDC_Stark  = 0; % Plot DC Stark shift and fit to quadratic
flagAC_Stark  = 0; % Plot AC Stark shift data
flagRydPlot   = 0; % Plotting important rydberg dressing values
flagAutTown   = 0; % Fit and plot the Autler-Townes data
flagPlotOff   = 0; % Plot data with offset but no fitting
flagBraggSc   = 1; % Calculate Bragg Scattering quantities
    scaleIntFlag  = 0; % Enable scaling Bragg populations by intensity read from scope
    plotBraggInt  = 0; % Plot the average Bragg power for every point
% Bragg Spectroscopy used for Rydberg Dressing
fitFuncBragg  = 'Gaussian'; % Functional form for fitting Bragg spectra
condBraggEdge = 0.05; % Percent height of BEC that is ignored for numerical integral of Bragg population
braggWinRad   = 6; % Pixel radius for numerically integrating Bragg signal
figNum.braggInt = 20141100; % Figure number for Bragg intensities;

% 86 Ground State Molecules
flagGSMoleInten = 1; % Load and analyze intensity fluctuations recorded during molecular spectroscopy
% Settings used for loading intensity data
picoChan = 'picoB';
%lenData  = 62500;  % Number of pnts in each vector from the picoscope
%sampTime = 1e-3;   % Amount of sampling time
fSamp    = 62.5e6; % When recording 10ms of data with a 16ns sampling interval

% PicoScope
picoChan    = {'picoA' 'picoB'}; % Cell containing which picoscope channels to expect. Valid options are picoA and/or picoB
picoFileExt = '.pico';

% Wavemeter
% sigParamAtom is colum name, not wavemeterAtom as one would expect. 


%% PHYSICAL QUANTITIES
%%-----------------------------------------------------------------------%%
mass         = isotope*1.66053892*10^(-27); % strontium mass (kg)
kBoltz       = 1.3806488e-23;  % Boltzmann constant
hbar         = 1.05457173e-34; % Planck's constant (J*s)
accelGrav    = 9.8;       % Acceleration due to gravity (m/s^2)
BohrRadius   = 0.53e-10;   % Bohr Radius in meter
lambda_1S0   = 460.862e-9; % 1S0->1P1 wavelength (nm)       
gamma_1S0_Hz = 30.5*10^6;  % 1S0->1P1 FWHM in Hz
satInten_1S0 = 42.5;       % 1S0->1P1 saturation intensity (mW/cm^2)
lambda_3P1   = 689.449e-9; % 1S0->3P1 wavelength (nm)
gamma_3P1_Hz = 7.5e3;      % 1S0->3P1 FWHM in Hz
satInten_3P1 = 2.98e-3;    % 1S0->3P1 saturation intensity (mW/cm^2)
CrossSection = 6*pi*(lambda_1S0/(2*pi))^2;
AbsCross     = CrossSection*1/(1 + (2*imgDetune/gamma_1S0_Hz)^2); %%% Pascal's PhD thesis (Eq. B.2)

% 3P1 Spectrscopy parameter
%resCntr_3P1 = 81.94; %MHz as of 2016.01.26 for Sr 84
%resCntr_3P1 = 81.748; %MHz as of 2016.02.01 for Sr 86 (in shallow ODT, 81.778 in freespace) 
resCntr_3P1 = 139.62; %MHz as of 2017.08.24 for Sr 87 in deepest ODT

% Offset Lock parameters
lcl_offsetFactor = -8; % Integer is the N/R ratio programmed into the OPLL. +/- depending on which side of resonance
lcl_AOMfreq      = -82; % MHz, from the master 689 laser which is locked -82 MHz of 88 (between 88 and 86)

% Lattice Parameters
lambdaLat    = 532e-9; % Lattice wavelength
recoilEnLat  = hbar^2*(2*pi/lambdaLat)^2/(2*mass); % One photon recoil energy of the lattice wavelength

% Bragg Spectroscopy Parameters
braggAngle    = 75;    % Full angle between beams (degrees)
braggDetune   = 182e6; % Detuning from intermediate state (Hz)
cntrAOM       = 100e3; % AOM freq. where no detuning between beams (Hz)
braggK        = 2*pi/lambda_3P1*sind(braggAngle/2);
recoilEnBragg = hbar^2*braggK^2/(2*mass);
cntr2hk       = 4*recoilEnBragg/(2*pi*hbar); %non-interacting Bragg resonance (Hz)
if braggAngle ~= 180 && sum(strcmpi(winToFit,{'Bragg'}))
    winToFit = 'Central';
elseif braggAngle == 180 && ~sum(strcmpi(winToFit,{'Bragg'}))
    winToFit = {'Central' 'Bragg'};
elseif braggAngle == 21
    flagNumIntBragg = 1;
    braggCalib      = 20/40; % pixels/millisecond calibration
end

%% ADDITIONAL PLOTTING VARIABLES
% Variables here may not be changed often so moved lower for the higher priority variables near the top
%%-----------------------------------------------------------------------%%
% Target specific plotting flags (all flags are booleans)
plotRawImage  = 0;             % Processed raw images (trimmed and binned) - needs implementation

plotNum       = plotInstParam; % Number in each image
plotMeanNum   = plotMeanParam; % Mean number averaged across similar scans

plotTemp      = plotInstParam; % Temperature of each image
plotMeanTemp  = plotMeanParam; % Mean temperature averaged across similar scans

plotSize      = plotInstParam; % Cloud radius of each image
plotMeanSize  = plotMeanParam; % Mean radius averaged across similar scans

plotTrapFreq     = plotInstParam; % Geometric average of trap frequencies
plotMeanTrapFreq = plotMeanParam; % Mean geometric average of trap frequencies

% Sub-plot placement parameters
subAxis.spacingVert  = 0.03;
subAxis.spacingHoriz = 2e-3;
subAxis.margin       = 0.01;
subAxis.marginTop    = 0.03;
subAxis.padding      = 0;

% Figure assignment
% Assign base figure number used in the imagefit routine (if assigning figures for lineshape fitting plots please consult
% this list first)
% Actual figure numbers will iterate from the base number
figNum.atomEvol = 1000;
figNum.fig2DFit = 1100;
figNum.figRes   = 1200;
figNum.fig1DFit = 1300;
figNum.fig1DBEC = 1400;
figNum.atomNum  = 2000;  figNum.meanNum  = 12000;
figNum.condNum  = 2100;  figNum.meanBEC  = 12100;
figNum.condFrac = 2200;  figNum.meanFrac = 12200;
figNum.atomSize = 3000;  figNum.meanSize = 13000;
figNum.atomTemp = 4000;  figNum.meanTemp = 14000;
figNum.trapFreq = 5000;  figNum.meanFreq = 15000;

%% GENERAL OUTPUT PARAMETER FILENAMES
%%-----------------------------------------------------------------------%%
ODimageFilename       = 'ODimagebatch.txt';
paramFitFileExt       = '.txt';
paramFitFilename      = 'FitParams';
BECNumCombineFilename = 'BEC-Holdtimes-Mean_Number-RMS_error.txt';

%% LABVIEW BATCHFILE VARIABLES
%%-----------------------------------------------------------------------%%
% Variables defined in lines of each dataset in the master batch file.
colHeadersAtom = {  'basenamevectorAtom' 
                    'timevectorAtom'
                    'ScanIDVarAtom'
                    'synthGrossFreq' 
                    'expTime' 
                    'droptimeAtom'
                    'roiWinRadAtom' 
                    'cloudWinRadAtom' 
                    'cloudColCntrAtom' 
                    'cloudRowCntrAtom'
                };
lcl_masterBatchAtomVar = colHeadersAtom(1:10)';
lcl_masterBatchBackVar = {'basenamevectorBack' 'unusedBack'};

% Variables defined in lines of the individual batch files
indivBatchAtomVar = {'fileAtom' 'imagevcoAtom' 'vcovoltageAtom' 'motdetuningAtom' 'ODTVoltageAtom' 'fugacityguessAtom',...
            'a' 'sigBECParamAtom' 'WeightedBECPeakAtom' 'BECamplitudeParameterAtom' 'sampleholdAtom' 'wavemeterAtom' 'sigParamAtom'};
indivBatchBackVar = {'fileBack' 'imagevcoBack' 'vcovoltageBack' 'motdetuningBack' 'ODTVoltageBack' 'fugacityguessBack',...
            'sigParamBack' 'sigBECParamBack' 'WeightedBECPeakBack' 'BECamplitudeParameterBack' 'sampleholdBack' 'wavemeterBack' 'aa'};

%% Image Acquisition Parameters
%%-----------------------------------------------------------------------%%
% Camera properties depend on resolution (Mi Yan's PhD thesis - 12.10.13)
switch CameraMag
    case 1
        CameraRes  = 5; %um
        pixelsize  = 6*10^(-6); %m/px
        
            % Calibration of diffraction peaks after free expansion, follows form of [Origin, +Z, -Z, +X, -X, +Y, -Y]
            % Found from image 6 of 2158 from 12.06.13 dataset with 11 ms drop with 1x objective
            LatFreeExpCalib = [0,20,-20,30,-30,31,-31,]./11;
        if sum(strcmpi(winToFit,'Bragg'))
            % Bragg Spectroscopy calibration - Added 2014.07.29
            % Calibration of diffraction peaks after free expansion, follows form of [Origin, +Z, -Z, +X, -X, +Y, -Y]
            % Found from image 21 of 1508 from 08.28.2014 dataset with 27 ms drop with 1x objective
            LatFreeExpCalib = [0,0,0,0,0,20,-20]./39;
        end
    case 4
        CameraRes  = 4.8; %um (Mi Yan PhD thesis, table A.5 - 12.11.13)
        pixelsize  = 1.5*10^(-6); %m/px
        
            % Calibration of diffraction peaks after free expansion, follows form of [Origin, +Z, -Z, +X, -X, +Y, -Y]
            % Found from image 17 of 2301 from 02.13.2014 dataset with 15 ms drop with 4x objective
            %LatFreeExpCalib = [0,100,-100,155,-155,178,-178]./15;
        if sum(strcmpi(winToFit,'Bragg'))
            error('4x objective not calibrated for Bragg Spectroscopy')
        end
    otherwise
        error('Camera magnification chosen is not a valid selection.')
end
pixelconv  = pixelsize*10^6; %converts meters to microns
sizefactor = pixelsize*softwareBinSize*CCDbinning; % effective pixelsize

%% Directory and master batch file parameters
%%-----------------------------------------------------------------------%%
% Add the library folders to the path
addpath(genpath([pwd filesep 'Library']));
rmpath([pwd filesep 'Library' filesep 'Archive']);

% Define default folder names for directory heirarchy
NeutExpDir      = 'Neutral_Experiment';
analyOutputName = 'Analysis';

%Two assumptions are made here,
% (1) - The batch directory is at the same folder level as the dataDirectory
% (2) - The batchhead files output by Labview are label as Files_yyyymmdd (Files_yyyymmdd_Bg for background)
% First need to determine file structure of Analysis folder
lcl_analyDir = pwd; % save Analysis Folder location
% Determine directory where all raw data files are saved (expected to mirror folder structure of Analysis folder
dataDir  = [strrep(lcl_analyDir,[filesep 'Analysis' filesep],[filesep 'Raw_Data' filesep]) filesep];
dataDirName = regexp(dataDir,filesep,'split'); dataDirName = regexp(dataDirName{end - 1},'_','split'); dataDirName = dataDirName{1};

% When testing use development data instead of real data (development purposes only)
%devSettings(v2struct(cat(1,'fieldNames',who())));

% Check if data directory exists
if not(exist(dataDir,'dir'))
    error('\nData Directory: %s\n not found. Please check analysis directory and try again.',dataDir)
end
% Check if analysis output directory exists, if not create
analyOutDir = [pwd filesep analyOutputName '_' dataDirName filesep]; % Output directory for analysis
if not(exist(analyOutDir,'dir'))
    mkdir([pwd filesep analyOutputName '_' dataDirName])
end
% NOTE: Win 7 has a filename limitation of 260 characters so if you get
% weird errors with dlmwrite look at the path name length

% Master batch file containing all datasets for the day
% If combining datasets to plot across multiple days create a new master batch file
% that shares the name of the folder without periods (i.e. \Data\...\2012.12.14_15_Combine\Files_2012121415_Combine.txt )
basenamelistAtom = [dataDir 'Files_' strrep(dataDirName,'.','') '.txt'];
basenamelistBack = [dataDir 'Files_' strrep(dataDirName,'.','') '_Bg' '.txt'];

% Read in list of variable names and determine the format string for textscan
lcl_varFormatStr = repmat({'%f'},1,length(lcl_masterBatchAtomVar)); % String is as long as number of variables
lcl_varFormatStr(1) = {'%s'};                                       % Define fixed variables
lcl_varFormatStr = horzcat(lcl_varFormatStr{:});                    % Concatenate cells into single string for textscan

% Read in variables for each data set defined in the master batch file
lcl_masterBatchAtomData = textscan(fopen(basenamelistAtom),lcl_varFormatStr,'commentstyle','%'); %data set batch files for atoms
lcl_masterBatchBackData = textscan(fopen(basenamelistBack),'%s%f','commentstyle','%');         %data set batch files for backgrounds

%%% Enumerate number of Basenames
numBasenamesAtom = size(lcl_masterBatchAtomData{1},1);
if ~numBasenamesAtom; error('No files enabled for analysis.'); end

%%% What kind of files are expected?
dataAtom = char('atoms.bny');
dataBack = char('back.bny');

%% Choose windows to analyze
%%-----------------------------------------------------------------------%%
% Follows form of [Origin, +Z, -Z, +X, -X, +Y, -Y]
% Default to central window only
%LatticeAxesFit = zeros(1,7);
LatticeAxesFit = cell(1,numBasenamesAtom);
LatticeAxesFit = cellfun(@(x) zeros(1,7),LatticeAxesFit,'UniformOutput',0); % Max number of different windows
latAxStr       = {'Z' 'X' 'Y'}; % Order of Lattice Axes in LatticeAxesFit
for lcl_j = 1:numBasenamesAtom
    if length(winToFit) > 1 && ~strcmpi(sampleType,{'Lattice'}) && ~sum(strcmpi(winToFit,{'Bragg'}))
        LatticeAxesFit{lcl_j}(1) = 1;
        % Warn about ignoring extra windows
        warning('imgFit:SampleType','SampleType is not Lattice, ignoring extra windows around peak')
    else
        for lcl_i = 1:length(winToFit)
            switch winToFit{lcl_i}
                case 'Central' % Origin
                    LatticeAxesFit{lcl_j}(1) = 1;
                case 'Arm A'    % X - axis (horizontal)
                    LatticeAxesFit{lcl_j}([4 5]) = 1;
                case 'Arm B'    % Z - axis (horizontal)
                    LatticeAxesFit{lcl_j}([2 3]) = 1;
                case 'Arm C'    % Y - axis (vertical)
                    LatticeAxesFit{lcl_j}([6 7]) = 1;
                case 'Bragg'
                    if lcl_masterBatchAtomData{4}(lcl_j) ~= 0 && flagBraggSc
                        lcl_braggSign = sign(lcl_masterBatchAtomData{4}(lcl_j));
                    else
                        error('imgFit:braggWin','Bragg direction not specified. Ignoring bragg window.')
                    end
                    
                    if lcl_braggSign == -1;
                        LatticeAxesFit{lcl_j}(6) = 1;
                    elseif lcl_braggSign == 1
                        LatticeAxesFit{lcl_j}(7) = 1;
                    end
                otherwise
                    error('No windows specified in winToFit.')
            end
        end
    end
end

%% Set sample specific fit type
%%-----------------------------------------------------------------------%%
% fitModel is a function handle that specifies which model to apply to the data
% NOTE: Lattice is fit using pure gaussian but with multiple windows
switch sampleType
    case {'Thermal' 'Lattice'}
        fitModel = 'PureGaussian'; 
        InitCase = 'Pure';
    case {'BEC'}
        if isotope == 88 && pureSample == 1
            fitModel = 'PureGaussian';
            InitCase = 'Pure';
        elseif isotope == 88 && pureSample == 0
            fitModel = 'BimodalGaussian';
            InitCase = 'Bimodal';
        elseif (isotope == 84 || isotope == 86) && pureSample == 1
            fitModel = 'PureThomasFermi';
            InitCase = 'Pure';
        elseif (isotope == 84 || isotope == 86) && pureSample == 0
            fitModel = 'BimodalThomasFermi';
            InitCase = 'Bimodal';
        end
    otherwise
        error('Invalid sample type specified. Check sampleType and try again')
end

%% Set the window used for fitting (of all sample types) and for plotting
% Also set the logical expression for using the masks (masks created in get_indiv_batch)
% NOTE: Unfortunately window references are not consistent throughout the
% imagefit routine. In general, I've regarded the ROI window as the plot
% window and the fit window as the cloud window.
lcl_fitWin  = lcl_masterBatchAtomData{strcmpi(lcl_masterBatchAtomVar,'cloudWinRadAtom')};
lcl_plotWin = lcl_masterBatchAtomData{strcmpi(lcl_masterBatchAtomVar,'roiWinRadAtom')};
funcFitWin  = @(x) (2*lcl_fitWin(x) + 1);  fitWinLogicInd  = @(winInd) (winInd == 1);
funcPlotWin = @(x) (2*lcl_plotWin(x) + 1); plotWinLogicInd = @(winInd) (winInd >= 0);

%% Define list of initial conditions that each model expects. 
% These names are used in getFitParams to determine how to calculate each value. 
% Be careful when changing or reordering.
% NOTE: Models are reparameterized to expect variables listed as posConstr to
%       be of the form logSigX = log(sigX) where logSigX is what is sent to
%       the model for fitting. This enforces a positivity constraint on the
%       width since a negative width is non-physical.
%       Additionally, variables listed under widthConstr are expected in
%       the form sigX^2 = sigX_BEC^2 + beta^2 where beta is the variable
%       sent to the model for fitting. This enforces that the thermal width
%       be greater than the BEC width.
% WARNING: Don't change the order of the guesses below without looking at
%          the function getFitParams (it expects this order)
switch InitCase
    case 'Pure'
        InitCondList = {'Amp' 'sigX' 'sigY' 'xCntr' 'yCntr' 'Offset' 'SlopeX' 'SlopeY'};
        findFromPeak = {'Amp' 'xCntr' 'yCntr'}; %These variables are found by smoothing and finding peak of data
    case 'Bimodal'
        InitCondList = {'Amp_BEC' 'sigX_BEC' 'sigY_BEC' 'Amp' 'sigX' 'sigY' 'xCntr' 'yCntr' 'Offset' 'SlopeX' 'SlopeY'};
        findFromPeak = {'Amp_BEC' 'xCntr' 'yCntr'}; %These variables are found by smoothing and finding peak of data
end

%% Control the independent variable prensentation
% There are two methods to control the independent variable, either (1) scaling
% or (2) applying a calibration. 
% (1) - Scaling 
% This process will not modfy the independent variable data read into and
% pass around by indivDataset, but will be (or should be) used when making
% plots so that plots are meaningful and not presented with "lab units". 
% Ex. You record a frequency (f) in MHz to a synth, but because of the
% experimental setup the physically relevant thing which is changing is
% actually 8*f, so to make meaningful plots you provide a funcDataScale
% below as an anonymous function that will scale your x-axis by 8. This
% function would look like funcDataScale = @(data) data*8;
% 
% (2) - Applying a calibration
% In rare cases you might actually need to change the independent data used
% in indivDataset by applying a calibration function (i.e. when using the wavemeter)
% This function will apply the calibration to the data when being read from
% disk so be careful about any changes you make when comparing datasets
% between days as application of the calibration could cause issue.
% Ex. You need to apply a calibration of V -> Wavenumber to improve
% frequency resolution of a laser. By defining a function below and turning
% the applyIndCalib = 1 (True) above, you can invoke a custom function to
% manipulate the independent variable. These calibration functions should
% only take in analyVar and indivBatch and need to output indivBatch. 
switch TimeOrDetune
    case 'Time'
        funcDataScale = @(data) data;
        xDataLabel    = 'Time [ms]';
        xDataUnit     = 'ms';
    case 'Detuning'
        lcl_Detuning_3P1 = lcl_masterBatchAtomData{strcmpi(lcl_masterBatchAtomVar,'synthGrossFreq')}(1);
        funcDataScale = @(data) (data - lcl_Detuning_3P1);
        xDataLabel    = 'Detuning [MHz]';
        xDataUnit     = 'MHz';
    case '3P1 Detuning'
        funcDataScale = @(data) data - resCntr_3P1;
        xDataLabel    = '^3P_1 Detuning [MHz]';
        xDataUnit     = 'MHz';
    case 'Offset Lock Detuning'
        funcDataScale = @(data) (data*lcl_offsetFactor) + (-82 + lcl_AOMfreq);
        xDataLabel    = 'Offset Detuning [MHz]';
        xDataUnit     = 'MHz';
    case 'Bragg'
        detuneCntr    = cntrAOM;
        funcDataScale = @(data) (data*1e3 - detuneCntr);
        xDataLabel    = 'Bragg Detuning [kHz]';
        xDataUnit     = 'kHz';
    case 'Voltage'
        funcDataScale = @(data) data;
        xDataLabel    = 'Voltage [V]';
        xDataUnit     = 'V';
    case 'Repumper'
        funcDataScale = @(data) data - 20776;
        xDataLabel    = 'Wavenumber from 20776 [cm^{-1}]';
        xDataUnit     = 'V';
    case 'Wavemeter' % In development
        res1P1 = 21698.452;
        funcDataScale = @(data) 299792458*1e-7.*(data - res1P1);
        %funcDataScale = @(data) data;
        funcIndCalib  = @(analyVar, indivBatch) fitWavemeterCalib(analyVar, indivBatch);
        xDataLabel    = sprintf('Detuning from %g [GHz]', res1P1);
        %xDataLabel    = 'Wavenumbers from 21698.452 [cm^{-1}]';
        xDataUnit     = 'GHz';
    otherwise
        error('Invalid selection for variable: TimeOrDetune. Please check the assignment.')
end

%% Check for valid lineshape fit arguments
fitLineFunc = lcl_validFitLine(nonzeros(lcl_logicFitLine.*(1:length(lcl_validFitLine))));
if  isempty(intersect(lcl_validFitLine,fitLineFunc)) && ~isempty(fitLineFunc)
    error('Invalid option in Fitlineshape.')
end
      
%% Setup fields for averaging datasets together
%%-----------------------------------------------------------------------%%
% Used in imagefit_Plotting routine
% Allows averaging across multiple datasets with same parameters
meanListVar  = lcl_masterBatchAtomData{strcmpi(lcl_masterBatchAtomVar,'ScanIDVarAtom')}; % Variable used to identify similar scans
uniqScanList = unique(meanListVar,'stable'); % Unique values between all scans (maintains order of appearance in meanListVar)
% Position of each occurence of unique value in meanListVar (sorted as uniqListVar). This finds each scan with similar 
% identifying variables andreturns the indices of all similar scans into a cell for each unique variable.
posOccurUniqVar = arrayfun(@(x) find(meanListVar == x),uniqScanList,'UniformOutput',0);
% Define precision to compare independent variables to (helps eliminate errors from comparing floating point number) 
compPrec = 1e7; % Will round numbers to the 7th decimal place
      
%% Create structure of variables
%%-----------------------------------------------------------------------%%
% First need to match the batch filename variables to their values
lcl_masterBatchVars = cell2struct(cat(2,lcl_masterBatchAtomData,lcl_masterBatchBackData),cat(2,lcl_masterBatchAtomVar,lcl_masterBatchBackVar),2);
% Concatenate masterBatch structure with another containing all other non-local variables. Lists fields alphabetically.
allVar   = who(); % analyVar is created with variables not starting with lcl_ (these are local variables that are not needed later in the analysis)
analyVar = catstruct(v2struct(cat(1,'fieldNames',allVar(cellfun('isempty',regexp(allVar,'\<lcl_'))))),lcl_masterBatchVars,'sorted');

%% Cleanup Workspace
fclose all; % Cleanup any open files just in case. Run before varCheck to guarantee file id's don't pile up in the global workspace.
end

function devSettings(allVar) %#ok<DEFNU>
%% Dev settings (for development purposes only)
% Workspace of Analysis variables is imported and unpacked via v2struct
% then variables in Analysis are directly manipulated using assignin
v2struct(allVar)

%% this is sample data, use for testing purposes only
switch sampleType
    case 'Thermal'
        devDataDir = '2014.01.16';
    case 'BEC'
        devDataDir = '2012.12.14';
        assignin('caller','TimeOrDetune','Detuning');
    case 'Lattice'
        devDataDir = '2013.12.17';
        assignin('caller','LatticeAxesFit',[1,0,0,1,1,0,0]);
        assignin('caller','winToFit',{'Central' 'Arm A'});
        assignin('caller','TimeOrDetune','Time');
end
assignin('caller','dataDir',regexprep(allVar.dataDir,[allVar.dataDirName '.*' filesep],[devDataDir filesep]));
assignin('caller','dataDirName',devDataDir);

sizefactorTmp = allVar.sizefactor/allVar.pixelsize;
pixelsize = 6e-6;
assignin('caller','pixelsize',pixelsize);
assignin('caller','sizefactor',sizefactorTmp*pixelsize);
assignin('caller','pixelconv',pixelsize*10^6); %converts pixels to microns
end